<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>SVO详解 | Blackant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="首先科普下计算机视觉和机器视觉 计算机视觉主要是质的分析，比如分类识别，这是一个杯子那是一条狗。或者做身份确认，比如人脸识别，车牌识别。或者做行为分析，比如人员入侵等。 机器视觉主要侧重对量的分析，比如用视觉去测量一个零件的直径。">
<meta property="og:type" content="article">
<meta property="og:title" content="SVO详解">
<meta property="og:url" content="http://yoursite.com/2018/05/07/SVO详解/index.html">
<meta property="og:site_name" content="Blackant">
<meta property="og:description" content="首先科普下计算机视觉和机器视觉 计算机视觉主要是质的分析，比如分类识别，这是一个杯子那是一条狗。或者做身份确认，比如人脸识别，车牌识别。或者做行为分析，比如人员入侵等。 机器视觉主要侧重对量的分析，比如用视觉去测量一个零件的直径。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/img/camera.png">
<meta property="og:image" content="http://yoursite.com/img/solvers.png">
<meta property="og:updated_time" content="2019-02-25T12:20:23.090Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SVO详解">
<meta name="twitter:description" content="首先科普下计算机视觉和机器视觉 计算机视觉主要是质的分析，比如分类识别，这是一个杯子那是一条狗。或者做身份确认，比如人脸识别，车牌识别。或者做行为分析，比如人员入侵等。 机器视觉主要侧重对量的分析，比如用视觉去测量一个零件的直径。">
<meta name="twitter:image" content="http://yoursite.com/img/camera.png">
  
    <link rel="alternate" href="/atom.xml" title="Blackant" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blackant</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-SVO详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/07/SVO详解/" class="article-date">
  <time datetime="2018-05-07T00:25:58.000Z" itemprop="datePublished">2018-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SVO详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<p>首先科普下计算机视觉和机器视觉</p>
<h2 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h2><p>主要是质的分析，比如分类识别，这是一个杯子那是一条狗。或者做身份确认，比如人脸识别，车牌识别。或者做行为分析，比如人员入侵等。</p>
<h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><p>主要侧重对量的分析，比如用视觉去测量一个零件的直径。<br><a id="more"></a></p>
<h2 id="接下来开始说论文的重点"><a href="#接下来开始说论文的重点" class="headerlink" title="接下来开始说论文的重点"></a>接下来开始说论文的重点</h2><p><strong>我们对于矩阵求逆的时候，要主要必须得保证这个矩阵是一个方阵才行哦</strong></p>
<h3 id="相机类型"><a href="#相机类型" class="headerlink" title="相机类型"></a>相机类型</h3><p>刚才介绍了普通的相机，现在介绍下RGB-D相机</p>
<ol>
<li>红外结构光来测量像素距离，例如kinect1</li>
<li>飞行时间法（ToF）测量像素距离，例如kinect2</li>
</ol>
<h3 id="相机映射模型"><a href="#相机映射模型" class="headerlink" title="相机映射模型"></a>相机映射模型</h3><p>由相似三角形比例得：这里负号是指反向的意思</p>
<script type="math/tex; mode=display">\frac{Z}{f}=-\frac{X}{X'}=-\frac{Y}{Y'}</script><p>由于相机内置旋转算法，所以我们拍出来的照片都是正面的</p>
<script type="math/tex; mode=display">\frac{Z}{f}=\frac{X}{X'}=\frac{Y}{Y'}</script><script type="math/tex; mode=display">X'=\frac{Xf}{Z}</script><script type="math/tex; mode=display">Y'=\frac{Yf}{Z}</script><p>照片上一点像素 <script type="math/tex">\vec p(u,v)</script> ，</p>
<script type="math/tex; mode=display">u=\alpha X'+c_{x}</script><script type="math/tex; mode=display">v=\beta Y'+c_{y}</script><script type="math/tex; mode=display">u=\alpha f\frac{X}{Z}+c_{x}</script><script type="math/tex; mode=display">v=\beta f\frac{Y}{Z}+c_{y}</script><script type="math/tex; mode=display">u=f_{x}\frac{X}{Z}+c_{x}</script><script type="math/tex; mode=display">v=f_{y}\frac{Y}{Z}+c_{y}</script><p>化成齐次矩阵</p>
<script type="math/tex; mode=display">\begin{bmatrix}
u\\
v\\
1\\
\end{bmatrix}=\frac{1}{Z} \begin{bmatrix}
f_{x}&0&c_{x}\\
0&f_{y}&c_{y}\\
0&0&1\\
\end{bmatrix} \begin{bmatrix}
X\\
Y\\
Z\\
\end{bmatrix}</script><script type="math/tex; mode=display">=\frac{1}{Z}KP</script><script type="math/tex; mode=display">Z\begin{bmatrix}
u\\
v\\
1\\
\end{bmatrix}=KP</script><p>其中 <script type="math/tex">K</script> 是内参，至此就是 <script type="math/tex">\mathbb{R}^{3} \mapsto \mathbb{R}^{2}</script></p>
<p>我们现在将推到 <script type="math/tex">\mathbb{R}^{2} \mapsto \mathbb{R}^{3}</script>，不过在此之前我们必须要知道距离<script type="math/tex">d</script></p>
<script type="math/tex; mode=display">Z=d</script><script type="math/tex; mode=display">X=\frac{u-c_{x}}{f_{x}}Z</script><script type="math/tex; mode=display">Y=\frac{u-c_{x}}{f_{x}}Z</script><p>上式就是<em>像素到相机坐标</em>的公式</p>
<p>内参属于相机出产自带的属性，我们可以通过棋盘标定法来实现相机的标定</p>
<h4 id="棋盘标定法"><a href="#棋盘标定法" class="headerlink" title="棋盘标定法"></a>棋盘标定法</h4><h4 id="推导外参"><a href="#推导外参" class="headerlink" title="推导外参"></a>推导外参</h4><p>接下来推倒外参，外参表示相机运动的参数</p>
<script type="math/tex; mode=display">Zp_{u,v}=Z\begin{bmatrix}
u\\
v\\
1\\
\end{bmatrix}</script><h3 id="向量到矩阵的变换"><a href="#向量到矩阵的变换" class="headerlink" title="向量到矩阵的变换"></a>向量到矩阵的变换</h3><h4 id="外积计算"><a href="#外积计算" class="headerlink" title="外积计算"></a>外积计算</h4><script type="math/tex; mode=display">\vec a\times \vec b=\begin{bmatrix}
i&j&k\\
a_{1}&a_{2}&a_{3}\\
b_{1}&b_{2}&b_{3}\\
\end{bmatrix}=\begin{bmatrix}
a_{2}b_{3}-a_{3}b_{2}\\
a_{3}b_{1}-a_{1}b_{3}\\
a_{1}b_{2}-a_{2}b_{1}\\
\end{bmatrix}=\begin{bmatrix}
0&-a_{3}&a_{2}\\
a_{3}&0&-a_{1}\\
-a_{2}&a_{1}&0\\
\end{bmatrix}\vec b</script><script type="math/tex; mode=display">=a^{\wedge}\vec b=\begin{bmatrix}
0&b_{3}&-b_{2}\\
-b_{3}&0&b_{1}\\
b_{2}&-b_{1}&0\\
\end{bmatrix}\vec a=-b^{\wedge}\vec a</script><p>故<script type="math/tex">a^{\wedge}\vec b=-b^{\wedge}\vec a</script>，这个公式转换很最重要在后文中有提及</p>
<h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><h4 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h4><p>相机运动是一个刚体运动，他保证了同一个向量在各个坐标系下的长度和夹角都不会发生变化，这种变换属于欧式变换。欧式变换包括了旋转和平移。首先我们考虑旋转。我们设某个正交单位基 <script type="math/tex">(e_{1},e_{2},e_{3})</script> 经过一次旋转后变成了 <script type="math/tex">(e'_{1},e'_{2},e'_{3})</script>，那么同一向量 <script type="math/tex">\vec a</script>，在两个坐标系下的坐标分别是 <script type="math/tex">[a_{1},a_{2},a_{3}]^T</script>和 <script type="math/tex">[a'_{1},a'_{2},a'_{3}]^T</script>。根据定义，有：</p>
<script type="math/tex; mode=display">(e_{1},e_{2},e_{3})\begin{bmatrix}
a_{1}\\
a_{2}\\
a_{3}\\
\end{bmatrix}=(e'_{1},e'_{2},e'_{3})\begin{bmatrix}
a'_{1}\\
a'_{2}\\
a'_{3}\\
\end{bmatrix}</script><p>两边同时左乘一个 \begin{bmatrix}<br>e^T<em>{1}\<br>e^T</em>{2}\<br>e^T_{3}\<br>\end{bmatrix}。</p>
<script type="math/tex; mode=display">\begin{bmatrix}
a_{1}\\
a_{2}\\
a_{3}\\
\end{bmatrix}=\begin{bmatrix}
e^T_{1}\\
e^T_{2}\\
e^T_{3}\\
\end{bmatrix}(e'_{1},e'_{2},e'_{3})\begin{bmatrix}
a'_{1}\\
a'_{2}\\
a'_{3}\\
\end{bmatrix}=\begin{bmatrix}
e^T_{1}e'_{1}&e^T_{2}e'_{1}&e^T_{3}e'_{1}\\
e^T_{2}e'_{1}&e^T_{2}e'_{2}&e^T_{2 }e'_{3}\\
e^T_{3}e'_{1}&e^T_{3}e'_{2}&e^T_{3}e'_{3}\\
\end{bmatrix}\begin{bmatrix}
a'_{1}\\
a'_{2}\\
a'_{3}\\
\end{bmatrix}=R\vec a'</script><p>其中 <script type="math/tex">R</script> 就是旋转矩阵 <em>此处解释了旋转矩阵为啥是乘法</em>，旋转矩阵满足一下性质</p>
<ol>
<li>秩为1</li>
<li>该矩阵与其转置相乘等于单位矩阵<br>我们把旋转矩阵的集合定义如下：<script type="math/tex; mode=display">SO(3)=\{R\ \in \mathbb{R}^{n*n}|RR^T=I,det(R)=1\}</script></li>
</ol>
<script type="math/tex; mode=display">SO(3)是特殊正交群的意思。
由于旋转的特殊性质，即可逆性。

$$\vec a'=R^{-1}\vec a=R^T\vec a</script><p>在欧式变换里，除了考虑旋转，还有平移。考虑到世界坐标系下的一个向量 <script type="math/tex">\vec a</script>,经过旋转和平移之后得到 <script type="math/tex">\vec a'</script>。</p>
<script type="math/tex; mode=display">\vec {a'}=R\vec a+t</script><h3 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h3><p>假设我们做了两次变换: <script type="math/tex">R_{1},t_{1}和 R_{2},t_{2}</script>，满足</p>
<script type="math/tex; mode=display">\vec b=R_{1}\vec a+t_{1}, \vec c=R_{2}\vec b+t_{2}</script><p>这样一来向量 <script type="math/tex">\vec c</script>计算比较复杂</p>
<script type="math/tex; mode=display">\vec c=R_{2}(R_{1}\vec a+t_{1})+t_{2}</script><p>引入齐次坐标和变换矩阵</p>
<script type="math/tex; mode=display">\begin{bmatrix}
\vec {a'}\\
1\\
\end{bmatrix}=\begin{bmatrix}
R&t\\
0^T&1\\
\end{bmatrix}\begin{bmatrix}
\vec a\\
1\\
\end{bmatrix}=T\begin{bmatrix}
\vec a\\
1\\
\end{bmatrix}</script><p>其中， <script type="math/tex">T</script>是变换矩阵(Transform Matrix)，本文我们定义 <script type="math/tex">\tilde{a}</script> 表示 <script type="math/tex">\vec a</script>的齐次坐标, <script type="math/tex">\tilde{b}</script> 表示 <script type="math/tex">\vec b</script>的齐次坐标, <script type="math/tex">\tilde{c}</script> 表示 <script type="math/tex">\vec c</script>的齐次坐标,</p>
<script type="math/tex; mode=display">\tilde{b}=T_{1} \tilde{a},\ \ \tilde{c}=T_{2} \tilde{b} => \tilde{c}=T_{2}T_{1} \tilde{a}</script><p>区分齐次和非齐次坐标符号很麻烦，我们直接就用 <script type="math/tex">\vec b=T \vec a</script>，代表齐次坐标。</p>
<p>关于变换矩阵 <script type="math/tex">T</script>，它的结构比较特殊，左上角为旋转矩阵，右上角为平移向量，左下角为0向量，右下角为1。这种特殊矩阵又称为特殊欧式群（Special Euclidean Group）：</p>
<script type="math/tex; mode=display">SE(3)=\begin{Bmatrix}T=\begin{bmatrix}R&t\\0^T&1\\\end{bmatrix} \in \mathbb{R}^{4*4}|R \in SO(3),t \in \mathbb{R}^3 \end{Bmatrix}</script><p>同理该矩阵的逆</p>
<script type="math/tex; mode=display">T^{-1}=\begin{bmatrix}R^T&-R^Tt\\0^T&1\end{bmatrix}</script><h3 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h3><p>假设有一个旋转轴为 <script type="math/tex">\vec n</script>，角度为 <script type="math/tex">\theta</script>，显然他对于的旋转向量为 <script type="math/tex">\vec n\theta</script>。从旋转向量都旋转矩阵的转换过程由罗德里格斯公式：</p>
<script type="math/tex; mode=display">R=cos\theta I+(1-cos\theta)\vec n\vec n^T+sin\theta \vec n^{\wedge}</script><p>这里 <script type="math/tex">^\wedge</script>是向量到反对称矩阵的转换符，见前面公式。</p>
<p><em>补充一个知识点，单位矩阵 I=\begin{bmatrix}1&amp;0&amp;0\0&amp;1&amp;0\0&amp;0&amp;1\end{bmatrix}</em></p>
<p>对于转角 <script type="math/tex">\theta</script>，有：</p>
<script type="math/tex; mode=display">tr(R)=cos\theta tr(I)+(1-cos\theta)tr(\vec n \vec n^T)+sin\theta tr(\vec n^{\wedge})</script><script type="math/tex; mode=display">=3cos\theta +(1-cos\theta)</script><script type="math/tex; mode=display">=1+2cos\theta</script><p>因此</p>
<script type="math/tex; mode=display">\theta=arccos(\frac{tr(R)-1}{2})</script><p><em>注： <script type="math/tex">tr(N)</script>，表示求矩阵 $N$的主对角元素之和。$tr(I)=3$，因为由于前面旋转矩阵推导可知，$R$是3\</em>3矩阵。 $\vec n^{\wedge}$ 是对角线为0的反对称矩阵，所以 $tr(\vec n^{\wedge})=0$。*</p>
<p>关于转轴 $\vec n$，由于旋转前后旋转轴不发生变化，所以</p>
<script type="math/tex; mode=display">R\vec n=\vec n</script><h3 id="李群"><a href="#李群" class="headerlink" title="李群"></a>李群</h3><p>李群的主要核心是表述连续变化的特性。变换矩阵包含的实际意义就是旋转和平移，所以肯定是连续的。故旋转矩阵和变换矩阵都是李群的一种，分别是特殊正交群和特殊欧式群。</p>
<h3 id="李代数"><a href="#李代数" class="headerlink" title="李代数"></a>李代数</h3><h4 id="so-3"><a href="#so-3" class="headerlink" title="so(3)"></a><script type="math/tex">so(3)</script></h4><p>我们知道旋转矩阵的一个性质</p>
<script type="math/tex; mode=display">RR^T=I</script><p>它是有时间意义的，随着时间不断的变化，所以可以写成对时间的函数：<script type="math/tex">R(t)</script></p>
<script type="math/tex; mode=display">R(t)R(t)^T=I</script><p>对时间<script type="math/tex">t</script>进行求导</p>
<script type="math/tex; mode=display">\dot{R}(t)R(t)^T+\dot{R}(t)^TR(t)=0</script><script type="math/tex; mode=display">\dot{R}(t)R(t)^T=-\dot{R}(t)^TR(t)</script><script type="math/tex; mode=display">\dot{R}(t)R(t)^T=-(\dot{R}(t)R(t)^T)^T</script><p>所以 <script type="math/tex">\dot{R}(t)R(t)^T</script> 是反对称矩阵。由前面介绍查积所知，向量到矩阵就是一个反对称矩阵。</p>
<script type="math/tex; mode=display">\vec a^{\wedge}=A=\begin{bmatrix}
0&-a_{3}&a_{2}\\
a_{3}&0&-a_{1}\\
-a_{2}&a_{1}&0\\
\end{bmatrix}, \ \ A^{\wedge}=\vec a</script><p>所以 <script type="math/tex">\dot{R}(t)R(t)^T</script> 必然对应一个向量 <script type="math/tex">\phi(t)^\wedge</script>。</p>
<p>于是</p>
<script type="math/tex; mode=display">\dot R(t)R(t)^T=\phi(t)^\wedge</script><p>右乘一个<script type="math/tex">R(t)</script>。</p>
<script type="math/tex; mode=display">\dot R(t)=\phi(t)^\wedge R(t)</script><p>当 <script type="math/tex">t_0=0</script>时，则还未开始旋转，所以 <script type="math/tex">R(t_0)=I</script>。 由一阶泰勒展开得：</p>
<script type="math/tex; mode=display">R(t)\approx R(t_0)+\dot{R}(t_0)(t-t_0)</script><p>将上式带入</p>
<script type="math/tex; mode=display">=I+\phi(t_0)^\wedge R(t_0)t</script><script type="math/tex; mode=display">=I+\phi(t_0)^\wedge t</script><p><em>我们看到 <script type="math/tex">\phi</script> 反映了 <script type="math/tex">R</script> 的导数性质，故称它在SO(3)原点附近的正切空间上。引用书上原话，我不是很明白</em></p>
<p>由齐次微分方程性质（<em><script type="math/tex">y'+p(x)y=0，通解为y=Ce^{-\int p(x)dx}</script></em>）得</p>
<script type="math/tex; mode=display">\dot R(t)=\phi(t)^\wedge R(t)</script><p>通解<script type="math/tex">R(t)=Ce^{\phi(t)^\wedge}</script></p>
<p>由于初始值<script type="math/tex">R(0)=I</script>,我们考虑的是<script type="math/tex">t_0=0</script>时，此时 <script type="math/tex">\phi(t_0)^\wedge</script> 为常数，故简化 <script type="math/tex">\phi(t_0)^\wedge</script>为 <script type="math/tex">\phi_0</script>所以其特解为</p>
<script type="math/tex; mode=display">\phi(0)^\wedge=0,\ C=I</script><script type="math/tex; mode=display">R(t)=e^{\phi_0^\wedge t}</script><p>对其换种写法也即</p>
<script type="math/tex; mode=display">R(t)=exp(\phi_0^\wedge t)</script><script type="math/tex; mode=display">\Phi=\phi^\wedge=\begin{bmatrix}0&-\phi_3&\phi_2\\\phi_3&0&-\phi_1\\-\phi_2&\phi_1&0\end{bmatrix}\in\mathbb{R}^{3\times 3}</script><p>一般我们说 <script type="math/tex">so(3)</script>的元素是3维向量或者3维反对称矩阵。</p>
<script type="math/tex; mode=display">so(3)=\begin{Bmatrix} \phi \in \mathbb{R}^3, \Phi=\phi^\wedge \in \mathbb{R}^{3\times 3} \end{Bmatrix}</script><p>与<script type="math/tex">SO(3)</script>的关系对应为</p>
<script type="math/tex; mode=display">R=exp(\phi^\wedge)</script><h4 id="se-3"><a href="#se-3" class="headerlink" title="se(3)"></a><script type="math/tex">se(3)</script></h4><p>同理我们可以推导</p>
<script type="math/tex; mode=display">se(3)=\begin{Bmatrix}\xi=\begin{bmatrix}\rho \\ \phi \end{bmatrix}\in \mathbb{R}^6,\ \rho \in \mathbb{R}^3,\ \phi \in so(3),\ \xi^\wedge=\begin{bmatrix}\phi^\wedge & \rho\\0^T&1 \end{bmatrix} \in \mathbb{R}^{4\times 4}\end{Bmatrix}</script><p>每个<script type="math/tex">se(3)</script> 的元素 <script type="math/tex">\xi</script>是六维向量，前三维是平移向量，记做 <script type="math/tex">\rho</script>。 后三维是旋转向量，记做 <script type="math/tex">\phi</script>。同时我们这里的 <script type="math/tex">\wedge</script>不再单纯表示向量到反对称矩阵，而是向量到矩阵的转换， <script type="math/tex">\vee</script>表示矩阵到向量的转换。</p>
<h3 id="SO-3-R-phi-wedge-指数映射"><a href="#SO-3-R-phi-wedge-指数映射" class="headerlink" title="SO(3)=R=\phi^\wedge 指数映射"></a><script type="math/tex">SO(3)=R=\phi^\wedge</script> 指数映射</h3><p>由于 <script type="math/tex">\phi</script>是三维向量，我们可以换种方式来定义它，通过模长 <script type="math/tex">\vec a</script> 和方向 <script type="math/tex">\theta</script>，这里 <script type="math/tex">\vec a</script>是长度为1的方向向量，对于 <script type="math/tex">a^\wedge</script>(后面我们不说明的情况下<script type="math/tex">a</script>就是 <script type="math/tex">\vec a</script>)，有以下两个性质:</p>
<p><em>PS:这是人家前人发现的，我们直接用就行了</em></p>
<script type="math/tex; mode=display">a^\wedge a^\wedge=aa^T-I</script><script type="math/tex; mode=display">a^\wedge a^\wedge a^\wedge=-a^\wedge</script><p><em>本文通过假设 <script type="math/tex">a^\wedge=\begin{bmatrix}0&-\frac{1}{\sqrt{3}}&\frac{1}{\sqrt{3}} \\ \frac{1}{\sqrt{3}}&0&-\frac{1}{\sqrt{3}} \\ -\frac{1}{\sqrt{3}}&\frac{1}{\sqrt{3}}&0\end{bmatrix}</script> ，强行往里带入可以验证上述性质成立</em></p>
<p>由麦克劳林公式得</p>
<script type="math/tex; mode=display">exp(x)=\sum_{k=0}^{\infty }\frac {1}{k!}x^n</script><script type="math/tex; mode=display">sinx=\sum_{k=1}^{\infty }(-1)^{k-1}\frac {1}{(2k-1)!}x^{2k-1}=x-\frac{1}{3!}x^3+\frac{1}{5!}x^5...</script><script type="math/tex; mode=display">cosx=\sum_{k=0}^{\infty }(-1)^k\frac {1}{2k!}x^{2k}=1-\frac{1}{2!}x^2+\frac{1}{4!}x^4+...</script><script type="math/tex; mode=display">exp(\phi^{\wedge})=\sum_{n=0}^{\infty }\frac {1}{n!}(\phi^{\wedge})^n</script><p>由上式得</p>
<script type="math/tex; mode=display">exp(\theta a^{\wedge})=\sum_{n=0}^{\infty }\frac {1}{n!}(\theta a^{\wedge})^n</script><script type="math/tex; mode=display">=I+\theta a+\frac {1}{2!}\theta^2 a^{\wedge}a^{\wedge}+\frac {1}{3!}\theta^3a^{\wedge}a^{\wedge}a^{\wedge}+\frac {1}{4!}\theta^4a^{\wedge}a^{\wedge}a^{\wedge}a^{\wedge}+...</script><p>将上式关于 <script type="math/tex">a^{\wedge}</script> 的次方推导公式，带入</p>
<script type="math/tex; mode=display">=I+\theta a+\frac {1}{2!}\theta^2 a^{\wedge}a^{\wedge}-\frac {1}{3!}\theta^3a^{\wedge}-\frac {1}{4!}\theta^4a^{\wedge}a^{\wedge}+\frac {1}{5!}\theta^5a^{\wedge}+\frac {1}{6!}\theta^6a^{\wedge}a^{\wedge}...</script><script type="math/tex; mode=display">=aa^T+(\theta-\frac{1}{3!}\theta^3+\frac{1}{5!}\theta^5-\frac{1}{7!}\theta^7+...)a^{\wedge}-(1-\frac{1}{2!}\theta^2+\frac{1}{4!}\theta^4-\frac{1}{6!}\theta^6+...)a^{\wedge}a^{\wedge}</script><script type="math/tex; mode=display">=a^{\wedge}a^{\wedge}+I+sin{\theta}a^{\wedge}-cos{\theta}a^{\wedge}a^{\wedge}</script><script type="math/tex; mode=display">=(1-cos{\theta})a^{\wedge}a^{\wedge}+I+sin\theta a^{\wedge}</script><script type="math/tex; mode=display">=cos\theta I+(1-cos\theta)aa^T+sin\theta a^{\wedge}</script><h3 id="SE-3-T-exp-xi-wedge-指数映射"><a href="#SE-3-T-exp-xi-wedge-指数映射" class="headerlink" title="SE(3)=T=exp(\xi^\wedge) 指数映射"></a><script type="math/tex">SE(3)=T=exp(\xi^\wedge)</script> 指数映射</h3><script type="math/tex; mode=display">exp(\xi^\wedge)=\begin{bmatrix}exp(\phi^{\wedge})&exp(\rho)\\ 0^T&0    \end{bmatrix}=\begin{bmatrix}\sum_{n=0}^{\infty }\frac {1}{n!}(\phi^{\wedge})^n&\sum_{n=0}^{\infty }\frac {1}{n!}(\rho)^n\\ 0^T&1\end{bmatrix}</script><script type="math/tex; mode=display">=\begin{bmatrix}\sum_{n=0}^{\infty }\frac {1}{n!}(\phi^{\wedge})^n&\sum_{n=0}^{\infty }\frac {1}{(n+1)!}(\phi^{\wedge})^n\rho\\ 0^T&1\end{bmatrix}</script><script type="math/tex; mode=display">=\begin{bmatrix}R&J\rho\\ 0^T&1\end{bmatrix}=T</script><p>即</p>
<script type="math/tex; mode=display">J=\sum_{n=0}^{\infty }\frac {1}{(n+1)!}(\phi^{\wedge})^n</script><p>按照之前推导$exp(\phi^{\wedge})$ 的思路，将$a^{\wedge}$ 平方和立方的计算规律带入得：</p>
<script type="math/tex; mode=display">J=\frac{sin\theta}{\theta}I+(1-\frac{sin\theta}{\theta})aa^T+\frac{(1-cos\theta)}{\theta}a^{\wedge}</script><p>图像像素灰度在k的时刻表示为I_k:Ω⊂R^2⊢R， 其中Ω是图像的整个域（二维的）。任意3维点p  在可见的场景表面S⊂R^3，通过相机投影模型 映射到图像的坐标</p>
<p>其中，前注k表示在k时刻相机框架点坐标的表示。投影函数π由相机内参（由校准之后得到）决定。3维点可以由图像坐标u恢复，不过需要给定反向投影函数π-1和深度</p>
<h4 id="总结下李群、李代数之间的关系"><a href="#总结下李群、李代数之间的关系" class="headerlink" title="总结下李群、李代数之间的关系"></a>总结下李群、李代数之间的关系</h4><p>李群是一个矩阵(R，T)，李代数是一个向量 $\phi$，$\xi$，每个李代数都可以对应一个反对称矩阵 $\phi^{\wedge}$，$\xi^{\wedge}$，同时我们对这个反对称矩阵求指数就是李群了。也即：</p>
<script type="math/tex; mode=display">exp(\phi^{\wedge})=R</script><script type="math/tex; mode=display">exp(\xi^{\wedge})=T</script><h3 id="为什么要提出李群，李代数"><a href="#为什么要提出李群，李代数" class="headerlink" title="为什么要提出李群，李代数"></a>为什么要提出李群，李代数</h3><p>李群为了更好的描述相机的运动，李代数是为了进一步更好的计算李群（单纯的李群是不容易直接进行数学运算的）</p>
<p>假设我们知道一个世界坐标系上的点p（路标点），运动了T之后，它的观测量为z，则理论上：</p>
<script type="math/tex; mode=display">z=Tp</script><p>然而我们知道真实情况系必然存在误差，所以应该是</p>
<script type="math/tex; mode=display">z=Tp+w</script><p>我们通常比较想知道计算理想和真实情况下的误差，使其最小</p>
<script type="math/tex; mode=display">e=z-Tp</script><p>假设我们有N个观测点和路标点，则</p>
<script type="math/tex; mode=display">minJ(T)=\sum_{i=1}^{N}\left \| z_i-Tp_i \right \|_{2}^{2}</script><p>我们的目标就是求$T$，使得整体误差$J$最小。</p>
<h4 id="BCH近似"><a href="#BCH近似" class="headerlink" title="BCH近似"></a>BCH近似</h4><script type="math/tex; mode=display">exp(\phi_1^{\wedge})exp(\phi_2^{\wedge})=exp(J_l^{-1}\phi_1+\phi_2), \ \phi_1微小</script><script type="math/tex; mode=display">exp(\phi_1^{\wedge})exp(\phi_2^{\wedge})=exp(J_r^{-1}\phi_2+\phi_1), \ \phi_2微小</script><p>其中$J_l=J=\frac{sin\theta}{\theta}I+(1-\frac{sin\theta}{\theta})aa^T+\frac{1-cos\theta}{\theta}a^{\wedge}$，它的逆</p>
<script type="math/tex; mode=display">J_l^{-1}=J^{-1}=\frac{\theta}{2}cot\frac{\theta}{2}I+(1-\frac{\theta}{2}cot\frac{\theta}{2})aa^T+\frac{\theta}{2}a^{\wedge}</script><p>右乘雅克比仅需要对自变量取符号即可：</p>
<script type="math/tex; mode=display">J_r(\phi)=J_l(-\phi)</script><p>将 $\phi_1^{\wedge}$ 与$J_l^{-1}\phi_1$对应，所以 $\phi_1$与 $(J_l\phi_1)^{\wedge}$ 对应。即：</p>
<script type="math/tex; mode=display">exp((\phi_1+\phi_2)^{\wedge})=exp((J_l\phi_1)^{\wedge})exp(\phi_2^{\wedge}), \ \phi_1微小</script><script type="math/tex; mode=display">exp((\phi_1+\phi_2)^{\wedge})=exp((J_r\phi_2)^{\wedge})exp(\phi_1^{\wedge}), \ \phi_2微小</script><h4 id="李代数求导"><a href="#李代数求导" class="headerlink" title="李代数求导"></a>李代数求导</h4><script type="math/tex; mode=display">\frac{\partial{Rp}}{\partial{R}}=\frac{\partial{(exp(\phi^{\wedge})p)}}{\partial{R}}</script><p>由导数定义可知</p>
<script type="math/tex; mode=display">\frac{\partial{(exp(\phi^{\wedge})p)}}{\partial{\phi}}=\lim_{\xi \phi\rightarrow 0}\frac{exp((\phi+\xi\phi)^{\wedge})p-exp(\phi^{\wedge})p}{\xi \phi}</script><script type="math/tex; mode=display">=\lim_{\xi \phi\rightarrow 0}\frac{exp((J_l\xi\phi)^{\wedge})exp(\phi^{\wedge})p-exp(\phi^{\wedge})p}{\xi \phi}</script><script type="math/tex; mode=display">=\lim_{\xi \phi\rightarrow 0}\frac{(I+(J_l\xi\phi)^{\wedge})exp(\phi^{\wedge})p-exp(\phi^{\wedge})}{\xi \phi}</script><script type="math/tex; mode=display">=\lim_{\xi \phi\rightarrow 0}\frac{(J_l\xi\phi)^{\wedge}exp(\phi^{\wedge})p}{\xi \phi}</script><p>从叉积公式得 $\vec a\times \vec b=a^{\wedge}b=-ab^{\wedge}$</p>
<script type="math/tex; mode=display">=\lim_{\xi \phi\rightarrow 0}\frac{-(exp(\phi^{\wedge})p)^{\wedge}(J_l\xi\phi)}{\xi \phi}</script><script type="math/tex; mode=display">=-(Rp)^{\wedge}J_l</script><p>自此，我们推导出旋转后的点相对于李代数的导数：</p>
<script type="math/tex; mode=display">\frac{\partial{Rp}}{\partial{\phi}}=-(Rp)^{\wedge}J_l</script><h4 id="扰动模型（左乘）"><a href="#扰动模型（左乘）" class="headerlink" title="扰动模型（左乘）"></a>扰动模型（左乘）</h4><script type="math/tex; mode=display">\frac{\partial{Rp}}{\partial{R}}=\lim_{
\varphi \rightarrow 0}\frac{exp(\varphi ^{\wedge})exp(\phi^{\wedge})p-exp(\phi^{\wedge})p}{\varphi}</script><script type="math/tex; mode=display">\approx \lim_{
\varphi \rightarrow 0}\frac{(1+\varphi^{\wedge})exp(\phi^{\wedge})p-exp(\phi^{\wedge})p}{\varphi}</script><script type="math/tex; mode=display">=\lim_{
\varphi \rightarrow 0}\frac{\varphi^{\wedge}exp(\phi^{\wedge})p}{\varphi}</script><script type="math/tex; mode=display">=\lim_{
\varphi \rightarrow 0}\frac{-(exp(\phi^{\wedge})p)^{\wedge}\varphi}{\varphi}</script><script type="math/tex; mode=display">=-(Rp)^{\wedge}</script><h3 id="SE-3"><a href="#SE-3" class="headerlink" title="SE(3)"></a>SE(3)</h3><p>其中， 是已知深度域<br>相机的位置和方向在k时刻用刚体变换 表示 SE(3)<br>我们可以映射一个3D点从世界坐标框架到参考相机框架<br>Tk,w就是上面说的外参，<br>两个连续帧直接相关变化可以用 计算<br>在优化过程中，我们需要最小的表示变化，因此，使用李代数se(3) 对应恒等于正切空间SE(3)。我们用代数元素ξ=〖(ω,υ)〗^T∈R^6表示旋转坐标，其中w是角速度和v线性速度。旋转坐标ξ用指数映射到SE(3)</p>
<h2 id="对极约束"><a href="#对极约束" class="headerlink" title="对极约束"></a>对极约束</h2><script type="math/tex; mode=display">s_{1}p_{1}=KP \ \ \ s_{2}p_{2}=K(RP+t)</script><p>$s_{1}$ 是一个数值，表示距离</p>
<p>对其进行归于化，得</p>
<script type="math/tex; mode=display">p_{1}=KP \ \ \ p_{2}=K(RP+t)</script><p>记</p>
<script type="math/tex; mode=display">x_{1}=K^{-1}p_{1} \ \ \ \ x_{2}=K^{-1}p_{2}</script><script type="math/tex; mode=display">x_{2}=Rx_{1}+t</script><p>两边同时乘以$t^{\wedge}$，由于$t^{\wedge}t=0$</p>
<script type="math/tex; mode=display">t^{\wedge}x_{2}=t^{\wedge}Rx_{1}</script><p>两边同时乘以$x_{2}^{T}$</p>
<script type="math/tex; mode=display">x_{2}^{T}t^{\wedge}x_{2}=x_{2}^{T}t^{\wedge}Rx_{1}</script><p>由于向量也是一维矩阵，所以左边满足矩阵乘法结合律</p>
<script type="math/tex; mode=display">(AB)C=A(BC)</script><p>由于$t^{\wedge}x<em>{2}$ 是垂直于$t$ 和 $x</em>{2}$ 的向量（一维矩阵），所以左边等0，即</p>
<script type="math/tex; mode=display">x_{2}^{T}t^{\wedge}Rx_{1}=0</script><p>将上面的$x<em>{1},x</em>{2}$ 代入</p>
<script type="math/tex; mode=display">p_{2}^{T}K^{-T}t^{\wedge}RK^{-1}p_{1}=0</script><p>令$E=t^{\wedge}R$(本质矩阵)，$F=K^{-T}EK^{-1}$（基础矩阵）</p>
<p>故</p>
<script type="math/tex; mode=display">x_{2}^{T}Ex_{1}=0, \ p_{2}^{T}Fp_{1}=0</script><p>根据特征点匹配求出$E$，从中分解出$R 和 t$ 出来即可<br>由E的性质可知，E为3*3的矩阵</p>
<p>对于任意的一对匹配点$x<em>{1}=[u</em>{1}, v<em>{1}, 1]^{T},x</em>{2}=[u<em>{2}, v</em>{2}, 1]^{T}$</p>
<script type="math/tex; mode=display">x_{2}^{T}Ex_{1}=0</script><script type="math/tex; mode=display">\begin{bmatrix}
u_{2} & v_{2} & 1
\end{bmatrix}\begin{bmatrix}
e_{1} & e_{2} & e_{3}\\
e_{4} & e_{5} & e_{6}\\
e_{7} & e_{8} & e_{9}
\end{bmatrix}\begin{bmatrix}
u_{1}\\
v_{1}\\
1
\end{bmatrix}=0</script><p>由矩阵乘法结合律</p>
<script type="math/tex; mode=display">\begin{bmatrix}
u_{2} & v_{2} & 1
\end{bmatrix}\begin{bmatrix}
u_{1}\\
v_{1}\\
1
\end{bmatrix}\begin{bmatrix}
e_{1} & e_{2} & e_{3}\\
e_{4} & e_{5} & e_{6}\\
e_{7} & e_{8} & e_{9}
\end{bmatrix}=0</script><p>将$E$写成向量的形式</p>
<script type="math/tex; mode=display">e=[e_{1}, e_{2}, e_{3}, e_{4}, e_{5}, e_{6}, e_{7}, e_{8}, e_{9}]^{T}</script><p>上式可以写成</p>
<script type="math/tex; mode=display">[u_{1}u_{2}, u_{2}v_{1}, u_{2}, v_{2}u_{1}, v_{1}v_{2}, v_{2}, u_{1}, v_{1}, 1]e=0</script><p>对于其他特征点也有同样的性质</p>
<script type="math/tex; mode=display">\begin{bmatrix}
 u_{1}^{1}u_{2}^{1}& u_{2}^{1}v_{1}^{1}& u_{2}^{1}& v_{2}^{1}u_{1}^{1}& v_{1}^{1}v_{2}^{1}& v_{2}^{1}& u_{1}^{1}& v_{1}^{1}& 1\\
 u_{1}^{2}u_{2}^{2}& u_{2}^{2}v_{1}^{2}& u_{2}^{2}& v_{2}^{2}u_{1}^{2}& v_{1}^{2}v_{2}^{2}& v_{2}^{2}& u_{1}^{2}& v_{1}^{2}& 1\\
 \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & 1\\
 u_{1}^{8}u_{2}^{8}& u_{2}^{8}v_{1}^{8}& u_{2}^{8}& v_{2}^{8}u_{1}^{8}& v_{1}^{8}v_{2}^{8}& v_{2}^{8}& u_{1}^{8}& v_{1}^{8}& 1\\
\end{bmatrix}\begin{bmatrix}
 e_{1}\\
 e_{2}\\
 e_{3}\\
 e_{4}\\
 e_{5}\\
 e_{6}\\
 e_{7}\\
 e_{8}\\
 e_{9}
\end{bmatrix}=0</script><h2 id="光束平差法-Bundle-Ajustment"><a href="#光束平差法-Bundle-Ajustment" class="headerlink" title="光束平差法(Bundle Ajustment)"></a>光束平差法(Bundle Ajustment)</h2><p>我们通过特征匹配的方式，已经可以到N组特征点</p>
<script type="math/tex; mode=display">z_{1}=\begin{Bmatrix}
z_{1}^{1},z_{1}^{2}....,z_{1}^{N}
\end{Bmatrix},z_{2}=\begin{Bmatrix}
z_{2}^{1},z_{2}^{2}....,z_{2}^{N}
\end{Bmatrix}</script><p>其中$z<em>{i}^{j}$ 下标是指第几帧图，上标表示第几个特征点，其在图像上的坐标为 $z</em>{i}^{j}=\left [ u,v \right ]_{i}^{j}$</p>
<p><img src="/img/camera.png" alt><br>上图模型表示为相机在1处，2处分别观测空间中X点位置。</p>
<script type="math/tex; mode=display">
\lambda_{1}\begin{bmatrix}
z_{1}^{j}\\
1
\end{bmatrix}=CX^{j},\lambda_{2}\begin{bmatrix}
z_{2}^{j}\\
1
\end{bmatrix}=C\left ( RX^{j}+t \right )</script><p>其中 $\lambda<em>{1},\lambda</em>{2}$ 表示像素深度值，也就是相机的z坐标。正常的思路就行，两个公式约掉 $X^{j}$ ，使用对极约束和SVD分解，理论上我们需要8个点就可以解算出来$R, t$，这是常规思路，我们这里主要介绍图优化。<br>我们尝试构造一个优化问题<br>由于存在着精度误差，所以 $\left | \frac{1}{\lambda<em>{1}}CX^{j}-\left [ z</em>{1}^{j},1 \right ]^{T}  \right |^{2}，\left | \frac{1}{\lambda<em>{2}}C(RX^{j}+t)-\left [ z</em>{2}^{j},1 \right ]^{T}  \right |^{2}$ 不可能都为0，所以我们只能通过调整 $R,t$ 来使他们的误差尽量下。</p>
<p>所以可以构造一个最优化问题，调整$R,t$使得对于所有的特征点$z^{j}$，误差二范数累计最小，也即</p>
<script type="math/tex; mode=display">
min_{X,R,t}\sum_{j=1}^{N}\left \| \frac{1}{\lambda_{1}}CX^{j}-\left [ z_{1}^{j},1 \right ]^{T}  \right \|^{2} + \left \| \frac{1}{\lambda_{2}}C(RX^{j}+t)-\left [ z_{2}^{j},1 \right ]^{T}  \right \|^{2}</script><p>这个就是最小化重投影误差问题（minimizaiton of reprojection error），实际操作中，我们在调整每个$X^{j}$，使得更符合每一次观测$z^{j}$，也就是每个误差项都尽量小。由于这个原因，所以他也叫捆绑调整（Bundle Adjustment）。</p>
<p>BA很容易描述成图优化形式。图的结点为</p>
<ul>
<li><p>相机的位置位姿：一个SE(3)的元素</p>
</li>
<li><p>空间中的特征点：是个XYZ坐标</p>
</li>
</ul>
<p>边主要是有空间点到像素坐标的投影关系。也就是</p>
<script type="math/tex; mode=display">\lambda_{2}\begin{bmatrix}
z_{2}^{j}\\
1
\end{bmatrix}=C\left ( RX^{j}+t \right )</script><p><em>注：向量转置与其本身实质和意义都是一样的，与矩阵不同</em></p>
<h2 id="g2o"><a href="#g2o" class="headerlink" title="g2o"></a>g2o</h2><p>其主要步骤如下：</p>
<ol>
<li>选择一个线性方程求解器，从 PCG, CSparse, Choldmod中选，实际则来自 g2o/solvers 文件夹中定义的文件夹。</li>
</ol>
<p><img src="/img/solvers.png" alt></p>
<figure class="highlight plain"><figcaption><span>使用Cholmod中的线性方程求解器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g2o::BlockSolver_6_3::LinearSolverType* linearSolver = new  g2o::LinearSolverCholmod&lt;g2o::BlockSolver_6_3::PoseMatrixType&gt; ();</span><br></pre></td></tr></table></figure>
<ol>
<li><p>选择一个 BlockSolver。</p>
<figure class="highlight plain"><figcaption><span>6*3 的参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g2o::BlockSolver_6_3* block_solver = new g2o::BlockSolver_6_3( linearSolver );</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择一个迭代策略，从GN, LM, Doglog中选。</p>
<figure class="highlight plain"><figcaption><span>L-M 下降</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g2o::OptimizationAlgorithmLevenberg* algorithm = new g2o::OptimizationAlgorithmLevenberg( block_solver );</span><br></pre></td></tr></table></figure>
<ol>
<li>构造结点和边</li>
</ol>
</li>
</ol>
<p>结点，空间中的点和位姿，边是有空间中的点跟像素坐标的投影关系</p>
<h4 id="测试BA和对级约束求解-详见ubuntu虚拟机的代码"><a href="#测试BA和对级约束求解-详见ubuntu虚拟机的代码" class="headerlink" title="测试BA和对级约束求解(详见ubuntu虚拟机的代码)"></a>测试BA和对级约束求解(详见ubuntu虚拟机的代码)</h4><p> <em>对极约束</em></p>
<script type="math/tex; mode=display">R=\begin{bmatrix}
0.9989066940689537 & -0.01520945268654653 & 0.04420507994800801\\
0.01389019427348682 & 0.9994533963165625 & 0.02999951823502051\\
-0.04463719354169673 & -0.02935270243545288 & 0.9985719502431745
 \end{bmatrix}, t=\begin{bmatrix}
 -0.287181547543988\\
  -0.1877533687454072\\
  -0.9392951779259762
 \end{bmatrix}</script><p> <em>BA</em></p>
<script type="math/tex; mode=display">
 R=\begin{bmatrix}
 0.999959 & -0.00778231 & -0.00471191\\
  0.0079586 & 0.999222 & 0.0386278\\
 0.00440763 & -0.0386637 & 0.999243
  \end{bmatrix}, t=\begin{bmatrix}
0.046212\\
-0.00945899\\
-0.00141173
  \end{bmatrix}</script><h3 id="最小光度误差"><a href="#最小光度误差" class="headerlink" title="最小光度误差"></a>最小光度误差</h3><p> 直接法主要根据灰度不变性假设进行实验，所以我们要实现最小光度误差<br> 等价于一个空间中的点，在两个不同位置上的相机投影产生的光度理论上是应该一致，所以整个最小化光度误差公式应由灰度方程组成。即</p>
<script type="math/tex; mode=display">
e=I_{1}(p_{1})-I_{2}(p_{2}),
\min_{\xi}J(\xi)=e^{T}e</script><p>$\xi$为相机变换李代数，不断调整相机位姿使得$e$的二范数值最小，这就是整个最小光度误差的原理。</p>
<p>由前面的投影方程可知</p>
<script type="math/tex; mode=display">
p_{1}=\begin{bmatrix}
u\\
v
\end{bmatrix}_{1}=D\frac{1}{Z_{1}}KP,p_{2}=\begin{bmatrix}
u\\
v
\end{bmatrix}_{2}=D\frac{1}{Z_{2}}K(RP+t)=D\frac{1}{Z_{2}}Kexp(\xi^\wedge)P</script><p>其中D是齐次到非齐次的转换</p>
<script type="math/tex; mode=display">
D=\begin{bmatrix}
1&0&0\\
0&1&0
\end{bmatrix}</script><p>因为空间中可能有许多类似于上述的三维点，所以构成了一个累和公式</p>
<script type="math/tex; mode=display">
\min_{\xi}J(\xi)=\sum_{i=1}^{N}e_{i}^{T}e_{i},e_{i}=I_{1}(p_{1,i})-I_{2}(p_{2,i})</script><p>既然要求最小值，所以一般我们先考虑其导数的情况，对于 $\min<em>{\xi}J(\xi)$ 的最小值，等价于求 $e</em>{i}$ 最小值，一般来说，我们想要求最小值先分析其导数比较合适，但是$e_{i}$不便对其进行求导，所以我们采用最基本的导数公式</p>
<script type="math/tex; mode=display">
f^{'}(x_{0})=\frac{f(x_{0}+\Delta x)-f(x_{0})}{\Delta x}</script><p>所以我们对 $e_{i}$ 加个扰动量，即</p>
<script type="math/tex; mode=display">
e(\xi \oplus \delta \xi )\\
=I_{1}(\frac{1}{Z_{1}}DKP)-I_{2}(\frac{1}{Z_{2}}DKexp(\delta\xi^\wedge)exp(\xi^\wedge)P)\\
\approx I_{1}(\frac{1}{Z_{1}}DKP)-I_{2}(\frac{1}{Z_{2}}DK(1+\delta\xi^\wedge)exp(\xi^\wedge)P)\\
=I_{1}(\frac{1}{Z_{1}}DKP)-I_{2}(\frac{1}{Z_{2}}DKexp(\xi^\wedge)P)-I_{2}(\frac{1}{Z_{2}}DK\delta\xi^\wedge exp(\xi^\wedge)P)\\
=e(\xi)-I_{2}(\frac{1}{Z_{2}}DK\delta\xi^\wedge exp(\xi^\wedge)P)\\</script><p>记， $q=\delta\xi^\wedge exp(\xi^\wedge)P$，$u=\frac{1}{Z_{2}}DKq$ 所以，上式一阶泰勒展开等于</p>
<script type="math/tex; mode=display">
e(\xi \oplus \delta \xi )\\
=e(\xi)-I_{2}(u)\\
\approx e(\xi)-\frac{\partial I_{2}}{\partial u}\frac{\partial u}{\partial q}\frac{\partial q}{\partial \delta\xi^\wedge}\delta\xi^\wedge</script><p>第一个式子 $\frac{\delta I_{2}}{\mathbf{u}}$ 是在 $\mathbf{u}$ 处的像素梯度<br>第二个式子 $\frac{\delta \mathbf{u}}{\delta q}$ 是投影方程关于相机坐标系下的三维点的导数。由前面的投影方程可知</p>
<script type="math/tex; mode=display">
u=\frac{f_{x}X+c_{x}}{Z},v=\frac{f_{y}Y+c_{y}}{Z}</script><p>于是，导数为</p>
<script type="math/tex; mode=display">
\frac{\partial \mathbf{u}}{\partial q}=\begin{bmatrix}
\frac{\partial u}{\partial X} & \frac{\partial u}{\partial Y} & \frac{\partial u}{\partial Z}\\
\frac{\partial v}{\partial X} & \frac{\partial v}{\partial Y} & \frac{\partial v}{\partial Z}
\end{bmatrix}\\
=\begin{bmatrix}
\end{bmatrix}</script><p> 误差相对于李代数的雅克比矩阵</p>
<script type="math/tex; mode=display">
J=\frac{\partial I_{2}}{\partial u}\frac{\partial u}{\partial \delta \xi }</script><h2 id="2018-2-25"><a href="#2018-2-25" class="headerlink" title="2018.2.25"></a>2018.2.25</h2><h3 id="Sophus"><a href="#Sophus" class="headerlink" title="Sophus"></a>Sophus</h3><p>Li algebra<br>Eigen is a matrix operation library, including create Vector and Matrix</p>
<h3 id="Opencv"><a href="#Opencv" class="headerlink" title="Opencv"></a>Opencv</h3><p>Mat can from a image file, and it’s has many invariables, like rows, cols, channel_number</p>
<p>also, we learn PointCloud, its has a function <strong>push_back（）</strong>, which can storage class PointT, IsometryId, ImageDepth, and ImageColor</p>
<p>In addition, formation from pixel frame to 3D frame. However, real World Point must use 3D frame multiple SE(3). like this:</p>
<p><code>Eigen::Vector3d pointWorld = T ** point;</code></p>
<p><strong>this function can save pointcloud map</strong></p>
<p><code>pcl::io::savePCDFileBinary(&quot;map.pcd&quot;, **pointCloud);</code></p>
<h2 id="2018-2-26"><a href="#2018-2-26" class="headerlink" title="2018.2.26"></a>2018.2.26</h2><h3 id="point"><a href="#point" class="headerlink" title="point"></a>point</h3><p>when we define a type point, like char* p, it means p is the type char of start address, as we all known each type has different bytes, float is 4 bytes, char is 1 bytes, each address is a bytes.</p>
<pre><code>char var = &#39;s&#39;;
int var = 12;
char* p = &amp;var;  // right
</code></pre><p><code>*p = var is value, and p = &amp;var is address</code></p>
<h3 id="OptimizationAlgorithm"><a href="#OptimizationAlgorithm" class="headerlink" title="OptimizationAlgorithm"></a>OptimizationAlgorithm</h3><h4 id="Guass-Newton"><a href="#Guass-Newton" class="headerlink" title="Guass-Newton"></a>Guass-Newton</h4><script type="math/tex; mode=display">
f(x+\Delta x)\approx f(x)+J(x)\Delta x. \\
\left \| f(x+\Delta x) \right \|_{2}^{2} \approx _{\Delta x}^{argmin}\frac{1}{2}\left \| f(x)+J(x)\Delta x \right \|_{2}^{2}.\\
=\frac{1}{2}(f(x)+J(x)\Delta x)^{T}(f(x)+J(x)\Delta x) \\
=\frac{1}{2}(\left \| f(x) \right \|_{2}^{2}+2f(x)J(x)^{T}\Delta x+\Delta x^{T}J(x)^{T}J(x)\Delta x)). \\</script><p>对 $\Delta x$进行求导，并令其为零。<br>so,</p>
<script type="math/tex; mode=display">
J(x)^{T}J(x)\Delta x=-f(x)J(x)^{T}</script><p>将左侧定义为H，右侧定义为g</p>
<script type="math/tex; mode=display">
H\Delta x=  g</script><h4 id="Levenberg-Marquardt"><a href="#Levenberg-Marquardt" class="headerlink" title="Levenberg-Marquardt"></a>Levenberg-Marquardt</h4><script type="math/tex; mode=display">
_{\Delta x}^{min}\frac{1}{2}\left \| f(x_{k})+J(x_{k})\Delta x_{k}\right \|^{2}+\frac{\lambda}{2}\left \|D\Delta x\right \|^{2}.\\
(H+\lambda D^{T}D)\Delta x = g.\\</script><p>we assume $D=I$ so,</p>
<script type="math/tex; mode=display">
(H+\lambda D^{T}D)\Delta x = g.\\</script><h4 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h4><p>functions:</p>
<p><code>1. Identity()</code></p>
<p>solve identity matrix（单位矩阵）</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1
\end{bmatrix}</script><p><code>2. transpose()</code></p>
<p>transposition of a matrix（矩阵的转置）</p>
<p><code>3. norm()</code></p>
<p>求向量的模长</p>
<h4 id="g2o-1"><a href="#g2o-1" class="headerlink" title="g2o"></a>g2o</h4><h3 id="2018-3-1"><a href="#2018-3-1" class="headerlink" title="2018.3.1"></a>2018.3.1</h3><h4 id="function-img-at"><a href="#function-img-at" class="headerlink" title="function: img.at()"></a>function: <code>img.at()</code></h4><p>for a single channel grey scale image, <em>img.at()</em> is get the value of intensity</p>
<p><code>Scalar intensity = img.at&lt;uchar&gt;(y, x)</code></p>
<p>when consider a 3 channel image with RGB color</p>
<pre><code>Vec3b intensity = img.at&lt;Vec3b&gt;(y, x);
uchar blue = intensity.val[0];
uchar green = intensity.val[1];
uchar red = intensity.val[2];
</code></pre><h4 id="struct-DMatch"><a href="#struct-DMatch" class="headerlink" title="struct DMatch"></a>struct DMatch</h4><p>Class for matching keypoint descriptors: query descriptor index, train descriptor index, train image index, and distance between descriptors.</p>
<h4 id="class-KeyPoint"><a href="#class-KeyPoint" class="headerlink" title="class KeyPoint"></a>class KeyPoint</h4><p>Data structure for salient point detectors.</p>
<p><em>Point2f pt</em></p>
<p>coordinates of the keypoint</p>
<p>so, <code>keypoints[m.queryIdx].pt.y</code> is y direction coordinate.</p>
<h4 id="pixel2cam"><a href="#pixel2cam" class="headerlink" title="pixel2cam"></a>pixel2cam</h4><script type="math/tex; mode=display">Z=d</script><script type="math/tex; mode=display">X=\frac{u-c_{x}}{f_{x}}Z</script><script type="math/tex; mode=display">Y=\frac{u-c_{x}}{f_{x}}Z</script><p>this forum is <strong>pixel2cam</strong></p>
<h3 id="2018-3-9"><a href="#2018-3-9" class="headerlink" title="2018.3.9"></a>2018.3.9</h3><h4 id="LK-OpticalFlow"><a href="#LK-OpticalFlow" class="headerlink" title="LK OpticalFlow"></a>LK OpticalFlow</h4><p>it’s main function is tracking and match features. it saves more time with respect to tranditional feature methods. So, when it finish match features, then, we should use SVD, PnP, ICP.</p>
<p><strong>calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, status, erros)</strong></p>
<h4 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter:"></a>Parameter:</h4><p>status – Output status vector. Each element of the vector is set to 1 if the flow for the corresponding features has been found. Otherwise, it is set to 0.</p>
<p><strong>简单说光流法是不是只做到了特征点跟踪的而已，等于替换了特征点法的特征点匹配那个步骤<br>如果要基于光流法得到相机的运动，是不是就需要继续补充PnP或者ICP，而且光流法如果想进一步使用BA原理进行计算运动的话，那是不是就是直接法的第一种，稀疏直接法</strong></p>
<h3 id="2018-3-14"><a href="#2018-3-14" class="headerlink" title="2018.3.14"></a>2018.3.14</h3><h4 id="OpticalFlow-essence"><a href="#OpticalFlow-essence" class="headerlink" title="OpticalFlow essence"></a>OpticalFlow essence</h4><ol>
<li>extract features with fast</li>
<li>match features using intensity consistent assume</li>
<li>if we want to farther get the pose of camera, in addition to, it needs to PnP or ICP after matching</li>
<li>if step three is to solver pose using BA based on the assume of consistent intensity, it is called direct method.</li>
</ol>
<h3 id="2018-3-18"><a href="#2018-3-18" class="headerlink" title="2018.3.18"></a>2018.3.18</h3><h4 id="Eigen-1"><a href="#Eigen-1" class="headerlink" title="Eigen"></a>Eigen</h4><p>这里是双精度，如果是单精度，只需要修改d为f即可</p>
<p>旋转矩阵（3*3）： Eigen::Matrix3d</p>
<p>旋转向量（3*1）：Eigen::AngleAxisd</p>
<p>欧拉角（3*1）：Eigen::Vector3d</p>
<p>四元数（4*1）：Eigen::Quaterniond</p>
<p>欧式变换矩阵（4*4）：Eigen::Isometry3d</p>
<p>仿射变换（4*4）：Eigen::Affine3d</p>
<p>射影变换（4*4）：Eigen::Projective3d</p>
<h4 id="schur消元"><a href="#schur消元" class="headerlink" title="schur消元"></a>schur消元</h4><p>对于线性方程</p>
<script type="math/tex; mode=display">
H \Delta x = g</script><p>求H矩阵的方法，其中 $\Delta x$ 是 $\Delta x<em>{c}=\begin{bmatrix}<br>\xi</em>{1}, &amp; \xi<em>{2}, &amp; …, &amp; \xi</em>{m}<br>\end{bmatrix}^{T} \in \mathbb{R}^{6m}, \Delta x<em>{p}=\begin{bmatrix}<br>p</em>{1}, &amp; p<em>{2}, &amp; …, &amp; p</em>{n}<br>\end{bmatrix}^{T} \in \mathbb{R}^{3n}$ 的统称，分别表示相机位姿和空间点的变量。</p>
<p>针对H矩阵的性质，我们将H矩阵分解成4块，$B, E, E^T, C$，该方法的精髓在于将一次性求解 $\Delta x, \Delta p$ 变成了先求解 $\Delta x$，再求解 $\Delta p$</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
B & E\\
E^T & C
\end{bmatrix}
\begin{bmatrix}
\Delta x_{c} \\
\Delta x_{p}
\end{bmatrix}=\begin{bmatrix}
\nu  \\
\omega
\end{bmatrix}</script><p>我们将两边同时乘以 $\begin{bmatrix}<br>I &amp; -EC^{-1}  \<br>0 &amp; I<br>\end{bmatrix}$</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
I & -EC^{-1}  \\
0 & I
\end{bmatrix}
\begin{bmatrix}
B & E\\
E^T & C
\end{bmatrix}
\begin{bmatrix}
\Delta x_{c} \\
\Delta x_{p}
\end{bmatrix}=\begin{bmatrix}
I & -EC^{-1}  \\
0 & I
\end{bmatrix}
\begin{bmatrix}
\nu  \\
\omega
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
B-EC^{-1}E^T & 0  \\
E^T & C
\end{bmatrix}
\begin{bmatrix}
\Delta x_{c} \\
\Delta x_{p}
\end{bmatrix}=\begin{bmatrix}
\nu-EC^{-1}\omega  \\
\omega
\end{bmatrix}</script><p>所以，就变成了先求 $(B-EC^{-1}E^T)\Delta x_{c} = \nu - EC^{-1}\omega$</p>
<p>之后将 $\Delta x<em>{c}$ 带入到 $\Delta x</em>{p}=C^{-1}(\omega - E^T\Delta x_{c})$ 即可</p>
<h2 id="2018-3-19"><a href="#2018-3-19" class="headerlink" title="2018.3.19"></a>2018.3.19</h2><h3 id="光流法的核心"><a href="#光流法的核心" class="headerlink" title="光流法的核心"></a>光流法的核心</h3><script type="math/tex; mode=display">
A\Delta x = -b \\
\Delta x = -(A^TA)^{-1}A^Tb</script><p>为啥要进行同时左乘一个 $A^T$ ，因为左边不是一个方阵，所以没法直接移过来求逆，所以我们需要通过变换，将其变成方阵</p>
<h3 id="卡尔曼滤波的推导"><a href="#卡尔曼滤波的推导" class="headerlink" title="卡尔曼滤波的推导"></a>卡尔曼滤波的推导</h3><p><strong>复合高斯分布的概念</strong></p>
<p>假设随机变量 $x \sim N(u<em>{x},\Sigma</em>{xx})$，另一个变量y满足：</p>
<script type="math/tex; mode=display">
y=Ax+b+w</script><p>其中 $A, b$ 为线性变量的系数矩阵和偏移量，$w$为噪声项，$w$ 为零均值的高斯分布：$w \sim N(0, R)$</p>
<p>y的高斯分布即为：</p>
<script type="math/tex; mode=display">
p(y)=N(Au_{x}+b, R+A\Sigma_{xx}A^{T})</script><p><strong>状态估计</strong></p>
<p>我们知道对于一个物体的状态估计应该分为预测和测量，其中预测主要是基于运动方程动模型得到的数据，测量主要是基于传感器等感知的数据</p>
<script type="math/tex; mode=display">
x_{k}=f(x_{k-1},u_{k}) + w  \\
z_{k}=h(x_{k}) + v</script><p>具体来说应该符合如下线性方程来描述：</p>
<script type="math/tex; mode=display">
x_{k}=A_{k}x_{k-1}+u_{k}+w_{k}  \\
z_{k}=C_{k}x_{k}+v_{k}</script><p>$C<em>{k}$ 也是状态变量到测量的转换矩阵。利用马尔可夫性，我们知道了k-1时刻的后验（在k-1时刻看来）状态估计 $\hat x</em>{k-1}$ 以及协方差 $\hat P<em>{k-1}$ ，现在要根据k时刻的输入（ $\hat x</em>{k-1}, \hat P<em>{k-1}$ ）和观测数据（ $z</em>{k}$ ），确定k时刻的后验分布 $\hat{x}<em>{k}$ 。为区分先验和后验，我们分别以 $\bar{x}</em>{k}$ ，$\hat{x}_{k}$ 表示。</p>
<p>其中假设 $x<em>{k-1}, z</em>{k}, w<em>{k}, v</em>{k}$ 是满足高斯分布，分别为 $x<em>{k-1} \sim N(\hat{x}</em>{k-1}, \hat{P}<em>{k-1}), w</em>{k} \sim N(0, R), v_{k} \sim N(0, Q)$</p>
<p>通过运动方程，确定 $x_{k}$ 的先验分布，根据复合高斯分布的性质，显然有</p>
<script type="math/tex; mode=display">
x_{k}\sim N(\bar{x}_{k},\bar P_{k}) \\
\bar{P}_{k}=A_{k}\hat{P}_{k-1}A^T_{k}+Q \\
\bar{x}_{k}=A_{k}\hat{x}_{k-1}+u_{k}\\
\\
z_{k} \sim N(C_{k}\bar{x}_{k}, C_{k}\bar{P}_{k-1}C^T_{k}+Q)</script><p>所以 $x<em>{k}$ ， $z</em>{k}$ 组成的联合高斯分布的形式为：</p>
<script type="math/tex; mode=display">
P(x_{k},z_{k})=N(\begin{bmatrix}
u_{x} \\
u_{y}
\end{bmatrix},\begin{bmatrix}
\Sigma_{xx} & \Sigma_{xy} \\
\Sigma_{yx} & \Sigma_{yy}
\end{bmatrix})\\
=N(\begin{bmatrix}
\bar x_{k} \\
C_{k}\bar x_{k}
\end{bmatrix},\begin{bmatrix}
\bar P_{k} & \bar P_{k}C^T_{k} \\
C_{k}\bar{P}_{k} & C_{k}\bar{P}_{k-1}C^T_{k}+Q
\end{bmatrix})</script><p>由于 $x<em>{k-1} \sim N(\hat{x}</em>{k-1}, \hat{P}<em>{k-1})$，即 $x</em>{k} \sim N(\hat{x}<em>{k}, \hat{P}</em>{k})$ 。由贝叶斯公式 $p(x,y)=p(x|y)p(y)$，下文引自公式</p>
<script type="math/tex; mode=display">
x_{k} \sim N(\hat{x}_{k}, \hat{P}_{k})=p(x|y)=p(x_{k}|z_{k})=N(u_{x}+\Sigma_{xx}\Sigma^{-1}_{xy}(y_{k}-u_{y}),\Sigma_{xx}-\Sigma_{xy}\Sigma^{-1}_{yy}\Sigma_{yx})</script><script type="math/tex; mode=display">
\hat x_{k}=\bar x_{k} + K_{k}(z_{k}-C_{k}\bar x_{k})\\
K_{k}=\bar P_{k}C^T_{k}(C_{k}\bar P_{k}C^T_{k}+R_{k})^{-1}\\
\hat P_{k}=(1-K_{k}C_{k})\bar P_{k}</script><p>贝叶斯滤波的基本假设：</p>
<ol>
<li>马儿可夫性假设：t时刻的状态由t-1时刻的状态和t时刻的动作决定。t时刻的观测仅同t时刻的状态相关，即：<script type="math/tex; mode=display">
p(x_t|x_{1:t-1}, z_{1:t}, u_{1:t})=p(x_t|x_{t-1},u_t)\\</script></li>
<li>观测噪声、模型噪声等是相互独立的</li>
<li>静态环境，即对象周边的环境假设是不变的</li>
</ol>
<script type="math/tex; mode=display">
Bel(x_t)=P(x_t|u_1, z_1, ..., u_t, z_t)\\
=\eta P(z_t|x_t) \int P(x_t|u_t, x_{t-1})P(x_{t-1}|u_1, z_1,...,z_{t-1})dx_{t-1}</script><h2 id="2018-3-20"><a href="#2018-3-20" class="headerlink" title="2018.3.20"></a>2018.3.20</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>先验概率 P(X)：仅仅依赖主观上的经验，事先根据已有的知识的推断</p>
<p>后验概率 P(X|Z)：是在相关证据或者背景给定并纳入考虑以后的条件概率</p>
<p>似然P(Z|X)：已知结果去推测固有性质的可能性</p>
<p>贝叶斯公式：</p>
<script type="math/tex; mode=display">
P(A|B)=\frac{P(A)\times P(B|A)}{P(B)}</script><p>后验分布正比于先验分布乘以似然</p>
<h2 id="2018-3-25"><a href="#2018-3-25" class="headerlink" title="2018.3.25"></a>2018.3.25</h2><h3 id="最大似然估计（Maximize-Likelihood-Estimation-MLE"><a href="#最大似然估计（Maximize-Likelihood-Estimation-MLE" class="headerlink" title="最大似然估计（Maximize Likelihood Estimation, MLE)"></a>最大似然估计（Maximize Likelihood Estimation, MLE)</h3><script type="math/tex; mode=display">
x_{MLE}^{*}=argmaxP(z|x)</script><p><strong>在怎样的状态下，最可能产生现在观测到的数据</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/07/SVO详解/" data-id="cjy09ah8s000agdxyluawwqy3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/12/[转]ROS机器人编程：原理与应用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          『转』ROS机器人编程：原理与应用
        
      </div>
    </a>
  
  
    <a href="/2018/01/19/《黑镜之光》综合科教书籍出版计划/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">《黑镜之光》综合科教书籍出版计划</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/robot/">robot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/robot/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/robot/Java/Android/">Android</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROS/">ROS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SAE/">SAE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bigdata/">bigdata</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/directions/">directions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/donation/">donation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/goal/">goal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello/">hello</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/helloworld/">helloworld</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot/">robot</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ROS/" style="font-size: 10px;">ROS</a> <a href="/tags/SAE/" style="font-size: 10px;">SAE</a> <a href="/tags/bigdata/" style="font-size: 10px;">bigdata</a> <a href="/tags/directions/" style="font-size: 10px;">directions</a> <a href="/tags/donation/" style="font-size: 10px;">donation</a> <a href="/tags/goal/" style="font-size: 20px;">goal</a> <a href="/tags/hello/" style="font-size: 10px;">hello</a> <a href="/tags/helloworld/" style="font-size: 10px;">helloworld</a> <a href="/tags/robot/" style="font-size: 10px;">robot</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/21/角度光流/">角度光流</a>
          </li>
        
          <li>
            <a href="/2019/03/20/Nature和Science关于机器人方面的文章总结/">Nature和Science关于机器人方面的总结</a>
          </li>
        
          <li>
            <a href="/2019/03/12/警犬项目经验总结/">警犬项目经验总结</a>
          </li>
        
          <li>
            <a href="/2019/03/12/[转]ROS机器人编程：原理与应用/">『转』ROS机器人编程：原理与应用</a>
          </li>
        
          <li>
            <a href="/2018/05/07/SVO详解/">SVO详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Hhu_GFBlab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>